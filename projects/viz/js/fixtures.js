// Generated by CoffeeScript 1.9.3
(function() {
  var deleteEdge, deleteNeighbour, deleteNode, dist, edgeObject, entities, firstGraphObject, getType, i, j, keywords, modifyGraph, newGraph, nodeObject, numberOfTopics, randomBoolean, randomChoice, randomEdges, randomFloat, randomSourcesList, resetGraph, setNode, topics, vary;

  numberOfTopics = 7;

  topics = (function() {
    var j, ref, results;
    results = [];
    for (i = j = 1, ref = numberOfTopics; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      results.push("topic " + i);
    }
    return results;
  })();

  entities = (function() {
    var j, ref, results;
    results = [];
    for (i = j = 1, ref = numberOfTopics * 100; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      results.push("entity " + i);
    }
    return results;
  })();

  keywords = (function() {
    var j, ref, results;
    results = [];
    for (i = j = 1, ref = numberOfTopics * 100; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      results.push("keyword " + i);
    }
    return results;
  })();

  randomFloat = function() {
    return Math.random();
  };

  dist = function() {
    return Math.random() * Math.random();
  };

  randomChoice = function(array) {
    return array[Math.floor(Math.random() * array.length)];
  };

  randomBoolean = function() {
    var a;
    a = (function() {
      var j, results;
      results = [];
      for (i = j = 0; j <= 7; i = ++j) {
        results.push(false);
      }
      return results;
    })();
    a.push(true);
    return randomChoice(a);
  };

  randomSourcesList = function() {
    var j, results;
    results = [];
    for (i = j = 1; j <= 4; i = ++j) {
      results.push({
        "name": "Source " + i,
        "degree": randomFloat()
      });
    }
    return results;
  };

  getType = function(list) {
    return list[0].split(" ")[0];
  };

  nodeObject = function(n, type, isnew, m) {
    return {
      "name": n,
      "type": type,
      "weight": {
        "metric": dist()
      },
      "emergence": {
        "new": isnew,
        "metric": dist(),
        "outlier": randomBoolean()
      },
      "source": randomSourcesList(),
      "neighbours": [m]
    };
  };

  edgeObject = function(n, m, isnew) {
    return {
      "nodes": [n, m],
      "weight": {
        "metric": dist()
      },
      "emergence": {
        "new": isnew,
        "metric": dist()
      },
      "source": randomSourcesList()
    };
  };

  setNode = function(graph, n, type, isnew, m) {
    if (!graph.nodes[n]) {
      return graph.nodes[n] = nodeObject(n, type, isnew, m);
    } else {
      return graph.nodes[n].neighbours.push(m);
    }
  };

  randomEdges = function(list1, list2, graph, iterations) {
    var isnew, j, l1, l2, n1, n2, ref, results;
    if (iterations == null) {
      iterations = 100;
    }
    l1 = list1.length;
    l2 = list2.length;
    results = [];
    for (i = j = 0, ref = Math.floor(iterations); 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      n1 = randomChoice(list1);
      n2 = randomChoice(list2);
      if (n1 !== n2 && !graph.edges[n1 + '-' + n2]) {
        isnew = randomBoolean();
        graph.edges[n1 + '-' + n2] = edgeObject(n1, n2);
        setNode(graph, n1, getType(list1), isnew, n2);
        results.push(setNode(graph, n2, getType(list2), false, n1));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  firstGraphObject = function(date) {
    var result;
    result = {
      "meta": {},
      "date": date,
      "nodes": {},
      "edges": {}
    };
    randomEdges(topics, keywords, result, 200);
    randomEdges(topics, entities, result, 200);
    randomEdges(keywords, keywords, result, 100);
    randomEdges(entities, keywords, result, 100);
    randomEdges(entities, entities, result, 100);
    return window.fixtures.push(result);
  };

  deleteEdge = function(n, m, graph) {
    var edge;
    edge = graph.edges[n + '-' + m];
    if (edge) {
      delete graph.edges[n + '-' + m];
    }
    return edge;
  };

  deleteNeighbour = function(n, m, graph) {
    i = _.indexOf(graph.nodes[m].neighbours, n);
    return graph.nodes[m].neighbours.splice(i, 1);
  };

  deleteNode = function(n, graph) {
    var j, len, m, node, ref;
    node = graph.nodes[n];
    if (node) {
      ref = node.neighbours;
      for (j = 0, len = ref.length; j < len; j++) {
        m = ref[j];
        deleteEdge(n, m, graph);
        deleteNeighbour(n, m, graph);
      }
      return delete graph.nodes[n];
    }
  };

  vary = function(x) {
    return x + (Math.random() * 2 - 1) / 10;
  };

  resetGraph = function(graph) {
    var edge, j, k, len, len1, node, ref, ref1, results;
    ref = graph.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      node.weight.metric = vary(node.weight.metric);
      node.emergence.metric = vary(node.emergence.metric);
      node.emergence["new"] = false;
      node.emergence.oulier = randomBoolean();
    }
    ref1 = graph.edges;
    results = [];
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      edge = ref1[k];
      edge.weight.metric = vary(edge.weight.metric);
      edge.emergence.metric = vary(edge.emergence.metric);
      results.push(edge.emergence["new"] = false);
    }
    return results;
  };

  modifyGraph = function(graph) {
    var j, k, n, r, ref, ref1;
    r = 5;
    for (i = j = 0, ref = r; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      n = randomChoice(entities);
      deleteNode(n, graph);
    }
    for (i = k = 0, ref1 = r; 0 <= ref1 ? k <= ref1 : k >= ref1; i = 0 <= ref1 ? ++k : --k) {
      n = randomChoice(keywords);
      deleteNode(n, graph);
    }
    randomEdges(topics, keywords, graph, r);
    randomEdges(topics, entities, graph, r);
    randomEdges(keywords, keywords, graph, r);
    randomEdges(entities, keywords, graph, r);
    return randomEdges(entities, entities, graph, r);
  };

  window.fixtures = [];

  firstGraphObject(void 0);

  for (i = j = 1; j <= 10; i = ++j) {
    newGraph = _.extendOwn({}, window.fixtures[i - 1]);
    modifyGraph(newGraph);
    window.fixtures.push(newGraph);
  }

}).call(this);
