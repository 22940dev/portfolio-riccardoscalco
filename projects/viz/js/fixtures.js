// Generated by CoffeeScript 1.9.3
(function() {
  var addEdge, arrayIntersect, arrayIntersect_, choose, deleteEdge, deleteNeighbour, deleteNode, dist, edgeNotExists, edgeObject, entities, firstGraphObject, getType, i, isTopic, keywords, linkToTopic, modifyGraph, nodeExists, nodeObject, numberOfTopics, randEdge, randomBoolean, randomChoice, randomFloat, randomSourcesList, resetGraph, topics, updateNeighboursAndTopics, updateNode, vary;

  numberOfTopics = 7;

  topics = (function() {
    var j, ref, results;
    results = [];
    for (i = j = 1, ref = numberOfTopics; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      results.push("topic " + i);
    }
    return results;
  })();

  entities = (function() {
    var j, ref, results;
    results = [];
    for (i = j = 1, ref = numberOfTopics * 100; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      results.push("entity " + i);
    }
    return results;
  })();

  keywords = (function() {
    var j, ref, results;
    results = [];
    for (i = j = 1, ref = numberOfTopics * 100; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      results.push("keyword " + i);
    }
    return results;
  })();

  arrayIntersect_ = function(arg1, arg2) {
    var hashMap, j, l, len, len1, o, retVal;
    retVal = [];
    hashMap = {};
    for (j = 0, len = arg1.length; j < len; j++) {
      l = arg1[j];
      hashMap[l] = 1;
    }
    for (o = 0, len1 = arg2.length; o < len1; o++) {
      l = arg2[o];
      if (hashMap[l] && ((hashMap[l] += 1) === 2)) {
        retVal.push(l);
      }
    }
    return retVal;
  };

  arrayIntersect = function(arg1, arg2) {
    if (arg1.length <= arg2.length) {
      return arrayIntersect_(arg1, arg2);
    }
    return arrayIntersect_(arg2, arg1);
  };

  randomFloat = function() {
    return Math.random();
  };

  dist = function() {
    return Math.random() * Math.random();
  };

  randomChoice = function(array) {
    return array[Math.floor(Math.random() * array.length)];
  };

  randomBoolean = function() {
    var a;
    a = (function() {
      var j, results;
      results = [];
      for (i = j = 0; j <= 7; i = ++j) {
        results.push(false);
      }
      return results;
    })();
    a.push(true);
    return randomChoice(a);
  };

  randomSourcesList = function() {
    var j, results;
    results = [];
    for (i = j = 1; j <= 4; i = ++j) {
      results.push({
        "name": "Source " + i,
        "degree": randomFloat()
      });
    }
    return results;
  };

  getType = function(list) {
    return list[0].split(" ")[0];
  };

  choose = function(p) {
    var n, prob, state;
    n = Math.random();
    for (state in p) {
      prob = p[state];
      if (n < prob) {
        return state;
      } else {
        n = n - prob;
      }
    }
    return state;
  };

  topics = {
    "topic 1": 0.3,
    "topic 2": 0.2,
    "topic 3": 0.1,
    "topic 4": 0.1,
    "topic 5": 0.1,
    "topic 6": 0.1,
    "topic 7": 0.1,
    "topic U": 0.0
  };

  isTopic = function(n) {
    return n.split(" ")[0] === "topic";
  };

  edgeNotExists = function(n1, n2, graph) {
    return !((graph.edges[n1 + '-' + n2] != null) || (graph.edges[n2 + '-' + n1] != null));
  };

  nodeExists = function(n, graph) {
    return graph.nodes[n] != null;
  };

  addEdge = function(t, n, graph) {
    if (edgeNotExists(t, n, graph)) {
      graph.edges[t + '-' + n] = edgeObject(t, n);
      updateNode(t, n, graph);
      return updateNode(n, t, graph);
    }
  };

  updateNeighboursAndTopics = function(s, t, graph) {
    var node;
    node = graph.nodes[s];
    node.neighbours.push(t);
    if (isTopic(t)) {
      return node.topics[t] = 1;
    }
  };

  updateNode = function(s, t, graph) {
    var type;
    if (nodeExists(s, graph)) {
      return updateNeighboursAndTopics(s, t, graph);
    } else {
      type = s.split(" ")[0];
      graph.nodes[s] = nodeObject(s, type, false);
      return updateNeighboursAndTopics(s, t, graph);
    }
  };

  linkToTopic = function(n, graph) {
    var t;
    t = choose(topics);
    return addEdge(t, n, graph);
  };

  randEdge = function(l1, l2, graph) {
    var e, intersect, k;
    e = randomChoice(l1);
    k = randomChoice(l2);
    intersect = arrayIntersect(d3.keys(graph.nodes[e].topics), d3.keys(graph.nodes[k].topics)).length > 0;
    if (edgeNotExists(e, k, graph)) {
      if (intersect) {
        if (Math.random() > 0.1) {
          return addEdge(e, k, graph);
        }
      } else {
        if (Math.random() > 0.9) {
          return addEdge(e, k, graph);
        }
      }
    }
  };

  nodeObject = function(n, type, isnew) {
    return {
      "name": n,
      "topics": {},
      "type": type,
      "weight": {
        "metric": dist()
      },
      "emergence": {
        "new": isnew,
        "metric": dist(),
        "outlier": randomBoolean()
      },
      "source": randomSourcesList(),
      "neighbours": []
    };
  };

  edgeObject = function(n, m, isnew) {
    return {
      "nodes": [n, m],
      "weight": {
        "metric": dist()
      },
      "emergence": {
        "new": isnew,
        "metric": dist()
      },
      "source": randomSourcesList()
    };
  };

  deleteEdge = function(n, m, graph) {
    var edge;
    edge = graph.edges[n + '-' + m];
    if (edge) {
      delete graph.edges[n + '-' + m];
    }
    return edge;
  };

  deleteNeighbour = function(n, m, graph) {
    i = _.indexOf(graph.nodes[m].neighbours, n);
    return graph.nodes[m].neighbours.splice(i, 1);
  };

  deleteNode = function(n, graph) {
    var j, len, m, node, ref;
    node = graph.nodes[n];
    if (node) {
      ref = node.neighbours;
      for (j = 0, len = ref.length; j < len; j++) {
        m = ref[j];
        deleteEdge(n, m, graph);
        deleteNeighbour(n, m, graph);
      }
      return delete graph.nodes[n];
    }
  };

  vary = function(x) {
    return x + (Math.random() * 2 - 1) / 10;
  };

  resetGraph = function(graph) {
    var edge, j, len, len1, node, o, ref, ref1, results;
    ref = graph.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      node.weight.metric = vary(node.weight.metric);
      node.emergence.metric = vary(node.emergence.metric);
      node.emergence["new"] = false;
      node.emergence.oulier = randomBoolean();
    }
    ref1 = graph.edges;
    results = [];
    for (o = 0, len1 = ref1.length; o < len1; o++) {
      edge = ref1[o];
      edge.weight.metric = vary(edge.weight.metric);
      edge.emergence.metric = vary(edge.emergence.metric);
      results.push(edge.emergence["new"] = false);
    }
    return results;
  };

  modifyGraph = function(graph) {
    var j, n, o, q, r, ref, ref1, ref2, results;
    r = 5;
    for (i = j = 0, ref = r; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      n = randomChoice(entities);
      deleteNode(n, graph);
    }
    for (i = o = 0, ref1 = r; 0 <= ref1 ? o <= ref1 : o >= ref1; i = 0 <= ref1 ? ++o : --o) {
      n = randomChoice(keywords);
      deleteNode(n, graph);
    }
    results = [];
    for (i = q = 0, ref2 = r; 0 <= ref2 ? q <= ref2 : q >= ref2; i = 0 <= ref2 ? ++q : --q) {
      randEdge(keywords, entities, graph);
      randEdge(entities, entities, graph);
      results.push(randEdge(keywords, keywords, graph));
    }
    return results;
  };

  firstGraphObject = function(date) {
    var e, j, k, len, len1, o, q, result;
    result = {
      "meta": {},
      "date": date,
      "nodes": {},
      "edges": {}
    };
    for (j = 0, len = keywords.length; j < len; j++) {
      k = keywords[j];
      linkToTopic(k, result);
    }
    for (o = 0, len1 = entities.length; o < len1; o++) {
      e = entities[o];
      linkToTopic(e, result);
    }
    for (i = q = 1; q <= 1000; i = ++q) {
      randEdge(keywords, entities, result);
      randEdge(entities, entities, result);
      randEdge(keywords, keywords, result);
    }
    return window.fixtures[0] = result;
  };

  window.fixtures = [];

  firstGraphObject(void 0);

}).call(this);
