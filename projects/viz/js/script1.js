// Generated by CoffeeScript 1.9.3
(function() {
  var dd, epsilon, force, getData, getLinks, graph, h, height, interGaussian, link, linkScale, links, m, node, nodeByName, nodes, nodesByName, rScale, svg, viz, w, width;

  graph = window.fixtures[0];

  getData = function(graph) {
    var nodes;
    return nodes = {
      nodes: _.values(graph.nodes),
      links: _.values(graph.edges)
    };
  };

  getLinks = function(graph) {
    var edges;
    edges = _.values(graph.edges);
    return edges.map(function(e) {
      return {
        "source": e.nodes[0],
        "target": e.nodes[1]
      };
    });
  };

  viz = document.getElementById('viz');

  width = 900;

  height = 900 / viz.offsetWidth * viz.offsetHeight;

  m = {
    top: 10,
    bottom: 10,
    right: 10,
    left: 10
  };

  w = width - m.left - m.right;

  h = height - m.top - m.bottom;

  force = d3.layout.force().charge(-300).chargeDistance(1).gravity(0).size([width, height]).linkStrength(0.1).friction(0.01).theta(0.8).alpha(0.1);

  rScale = d3.scale.linear().domain([0, 1]).range([0.1, 3]);

  linkScale = d3.scale.linear().domain([0, 1]).range([10, 0]);

  svg = d3.select("#viz").append("svg").attr({
    "viewBox": "0 0 " + width + " " + height,
    "preserveAspectRatio": "xMidYMin slice",
    "width": "100%"
  }).style({
    "padding-bottom": (100 * height / width) + "%",
    "height": "1px",
    "overflow": "visible"
  }).append("g").attr("transform", "translate(" + m.left + "," + m.top + ")");

  links = getLinks(window.fixtures[0]);

  nodesByName = {};

  nodeByName = function(name) {
    return nodesByName[name] || (nodesByName[name] = {
      name: name
    });
  };

  links.forEach(function(link) {
    link.source = nodeByName(link.source);
    return link.target = nodeByName(link.target);
  });

  nodes = d3.values(nodesByName);

  force.nodes(nodes).links(links).linkDistance(function(d) {
    m = graph.edges[d.source.name + '-' + d.target.name].weight.metric;
    return linkScale(m);
  }).start();

  link = svg.selectAll(".link").data(links).enter().append("line").attr("class", "link");

  node = svg.selectAll(".node").data(nodes).enter().append("circle").attr("class", function(d) {
    var error, t;
    try {
      t = graph.nodes[d.name].topics;
      return "node q" + t[0].split(" ")[1];
    } catch (_error) {
      error = _error;
      return "node";
    }
  }).attr("r", function(d) {
    var error;
    try {
      if (graph.nodes[d.name].type === "topic") {
        return 0;
      } else {
        return rScale(graph.nodes[d.name].weight.metric);
      }
    } catch (_error) {
      error = _error;
      return 2;
    }
  }).call(force.drag);

  node.append("title").text(function(d) {
    return d.name;
  });

  epsilon = function(h) {
    return h / 20 * Math.random();
  };

  interGaussian = function(x, y) {
    var alpha, dx, dy, g, mu, sigma;
    dx = width / 2;
    dy = height / 2;
    alpha = 25000;
    sigma = Math.sqrt(90000);
    mu = dx;
    g = alpha * 1 / sigma * Math.exp(-(Math.pow(x - mu, 2)) / (2 * Math.pow(sigma, 2)));
    return Math.min(dy + g, Math.max(dy - g, y));
  };

  dd = height / 3;

  force.on("tick", function() {
    node.attr("cx", function(d) {
      return d.x = Math.max(0, Math.min(width, d.x));
    }).attr("cy", function(d) {
      return d.y = Math.max(dd, Math.min(height - dd, d.y));
    });
    return link.attr("x1", function(d) {
      return d.source.x;
    }).attr("y1", function(d) {
      return d.source.y;
    }).attr("x2", function(d) {
      return d.target.x;
    }).attr("y2", function(d) {
      return d.target.y;
    });
  });

}).call(this);
